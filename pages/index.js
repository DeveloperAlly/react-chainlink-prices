import Head from "next/head";
import Image from "next/image";
import styles from "../styles/Home.module.css";
import web3 from "./api/web3";
import PriceFeedInstance from "./api/contracts/PriceFeed";
import PriceOriginalInstance from "./api/contracts/PriceOriginal";
import TestMappingInstance from "./api/contracts/TestMapping";
import React, { useState, useEffect, useRef } from "react";

const Home = (props) => {
  const [prices, setPrices] = useState({
    ETHUSD: null,
    BTCUSD: null,
    LINKUSD: null,
    AUDUSD: null,
    DOGEY: null,
  });
  const [priceInfo, setPriceInfo] = useState(null);
  const REFRESH_INTERVAL = 5000;

  const useInterval = (callback, delay) => {
    const savedCallback = React.useRef();

    React.useEffect(() => {
      savedCallback.current = callback;
    }, [callback]);

    React.useEffect(() => {
      function tick() {
        savedCallback.current();
      }
      if (delay !== null) {
        let id = setInterval(tick, delay);
        return () => clearInterval(id);
      }
    }, [delay]);
  };

  useEffect(() => {
    // console.log(PriceFeedInstance.methods);
    // console.log(TestMappingInstance.methods);
    getPrices();
    //   console.log(ethAddress);
  }, []);

  useInterval(async () => {
    getPrices();
  }, REFRESH_INTERVAL);

  const getPrices = async () => {
    //Object.keys(prices) will return an array of our tickers eg Object.keys(prices) returns ["ETHUSD", "BTCUSD"...]
    //We will then map over this array of keys we just created - note the async keyword in the function.
    //We use the async keyword because we are calling data that returns with some delay (asynchronously), so
    //This data will return a "Promise" of fulfillment -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise
    //The .map function will return an Array of Promise objects
    const pricePromises = Object.keys(prices).map(async (ticker) => {
      const tickerPrice = await getAPrice(ticker); //Have a look at the getAPrice function to see what it does
      console.log("tickerprice", tickerPrice);
      return tickerPrice;
    });
    console.log("pricePromises", pricePromises);

    //This is where we will resolve the Promise object Array into the data we requested (this can wrap the call above too for a one liner!)
    const pricesArray = await Promise.all(pricePromises);
    console.log("pricesArray", pricesArray);

    //Now we'll convert this back to the object we need for our prices state
    const pricesObj = Object.fromEntries(pricesArray);
    console.log(pricesObj);

    //Now we set the state for the rest of our React function to read
    setPrices(pricesObj);
    setPriceInfo(true);
  };

  //This method calls the blockchain contract which fetches a price for the provided ticker using Chainlink price feed oracles
  const getAPrice = async (ticker) => {
    //call the asynchronous contract data
    return await PriceFeedInstance.methods
      .getLatestPrice(ticker)
      .call()
      //.then will return a resolved Promise
      .then((priceReturned) => {
        console.log(priceReturned);
        // setPrices({ ...prices, [ticker]: priceReturned });
        return [ticker, priceReturned / 100000000];
      })
      //.catch - if something goes wrong in this data call, this will be how we handle it
      .catch((err) => {
        console.log(err); //an error occurred but we still want to return an object for this
        // setPrices({ ...prices, [ticker]: priceReturned });
        return [ticker, null]; //we'll set this to null
      });
  };

  const renderCard = (details) => {
    return (
      <>
        <a href="" target="_blank" className={styles.card}>
          <h2>{}</h2>
          <p>${prices.ETHUSD.toFixed(2)}</p>
        </a>
      </>
    );
  };

  return (
    <div className={styles.container}>
      <Head>
        <title>Chainlink Demo</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/chainlink-link-logo.png" />
      </Head>

      <main className={styles.main}>
        <h1 className={styles.title}>
          Welcome to <a href="https://nextjs.org">Bris.js!</a>
        </h1>

        <p className={styles.description}>
          Getting started with Web3 and React
          <code className={styles.code}> - DeveloperAlly</code>
        </p>

        {priceInfo ? (
          <div className={styles.grid}>
            <a href="https://nextjs.org/docs" className={styles.card}>
              <h2>ETH/USD Timer</h2>
              <p>${prices.ETHUSD.toFixed(2)}</p>
            </a>
            <a href="https://nextjs.org/docs" className={styles.card}>
              <h2>ETH/USD</h2>
              <p>${prices.ETHUSD.toFixed(2)}</p>
            </a>
            <a href="https://nextjs.org/docs" className={styles.card}>
              <h2>ETH/USD</h2>
              <p>${prices.ETHUSD.toFixed(2)}</p>
            </a>

            <a href="https://nextjs.org/learn" className={styles.card}>
              <h2>BTC/USD</h2>
              <p>${prices.BTCUSD.toFixed(2)}</p>
            </a>

            <a
              href="https://github.com/vercel/next.js/tree/master/examples"
              className={styles.card}
            >
              <h2>LINK/USD </h2>
              <p>${prices.LINKUSD.toFixed(2)}</p>
            </a>

            <a
              href="https://vercel.com/new?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
              className={styles.card}
            >
              <h2>AUD/USD </h2>
              <p>${prices.AUDUSD.toFixed(3)}</p>
            </a>
          </div>
        ) : (
          <div>Loading Prices...</div>
        )}
      </main>

      <footer className={styles.footer}>
        <a
          href="https://vercel.com?utm_source=create-next-app&utm_medium=default-template&utm_campaign=create-next-app"
          target="_blank"
          rel="noopener noreferrer"
        >
          <span className={styles.logo}>
            <Image
              src="/PoweredByChainlinkBlue.svg"
              alt="Chainlink Logo"
              width={250}
              height={30}
            />
          </span>
        </a>
      </footer>
    </div>
  );
};

// Home.getInitialProps = async () => {
//   const ethAddress = await PriceFeed.methods.getAddress("ETHUSD").call();
//   console.log(ethAddress);
//   return ethAddress;
// };

export default Home;

/*
const web3 = new Web3("https://kovan.infura.io/v3/<infura_project_id>");
const aggregatorV3InterfaceABI = [
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "description",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ internalType: "uint80", name: "_roundId", type: "uint80" }],
    name: "getRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "latestRoundData",
    outputs: [
      { internalType: "uint80", name: "roundId", type: "uint80" },
      { internalType: "int256", name: "answer", type: "int256" },
      { internalType: "uint256", name: "startedAt", type: "uint256" },
      { internalType: "uint256", name: "updatedAt", type: "uint256" },
      { internalType: "uint80", name: "answeredInRound", type: "uint80" },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
];
const addr = "0x9326BFA02ADD2366b30bacB125260Af641031331";
const priceFeed = new web3.eth.Contract(aggregatorV3InterfaceABI, addr);
priceFeed.methods
  .latestRoundData()
  .call()
  .then((roundData) => {
    // Do something with roundData
    console.log("Latest Round Data", roundData);
  });
*/
